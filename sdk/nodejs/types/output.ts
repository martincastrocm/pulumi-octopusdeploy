// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AzureCloudServiceDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.AzureCloudServiceDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.AzureCloudServiceDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.AzureCloudServiceDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.AzureCloudServiceDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface AzureCloudServiceDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface AzureCloudServiceDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface AzureCloudServiceDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface AzureCloudServiceDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface AzureServiceFabricClusterDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.AzureServiceFabricClusterDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.AzureServiceFabricClusterDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.AzureServiceFabricClusterDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.AzureServiceFabricClusterDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface AzureServiceFabricClusterDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface AzureServiceFabricClusterDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface AzureServiceFabricClusterDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface AzureServiceFabricClusterDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface AzureWebAppDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.AzureWebAppDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.AzureWebAppDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.AzureWebAppDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.AzureWebAppDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface AzureWebAppDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface AzureWebAppDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface AzureWebAppDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface AzureWebAppDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface ChannelRule {
    actionPackages: outputs.ChannelRuleActionPackage[];
    /**
     * The unique ID for this resource.
     */
    id: string;
    tag?: string;
    versionRange?: string;
}

export interface ChannelRuleActionPackage {
    deploymentAction?: string;
    packageReference?: string;
}

export interface CloudRegionDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.CloudRegionDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.CloudRegionDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.CloudRegionDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.CloudRegionDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface CloudRegionDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface CloudRegionDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface CloudRegionDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface CloudRegionDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface DeploymentProcessStep {
    actions?: outputs.DeploymentProcessStepAction[];
    /**
     * (see below for nested schema)
     */
    applyTerraformTemplateActions?: outputs.DeploymentProcessStepApplyTerraformTemplateAction[];
    /**
     * When to run the step, one of 'Success', 'Failure', 'Always' or 'Variable'
     */
    condition?: string;
    /**
     * The expression to evaluate to determine whether to run this step when 'condition' is 'Variable'
     */
    conditionExpression: string;
    deployKubernetesSecretActions?: outputs.DeploymentProcessStepDeployKubernetesSecretAction[];
    deployPackageActions?: outputs.DeploymentProcessStepDeployPackageAction[];
    deployWindowsServiceActions?: outputs.DeploymentProcessStepDeployWindowsServiceAction[];
    /**
     * The unique ID for this resource.
     */
    id: string;
    manualInterventionActions?: outputs.DeploymentProcessStepManualInterventionAction[];
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * Whether to run this step before or after package acquisition (if possible)
     */
    packageRequirement?: string;
    properties: {[key: string]: any};
    runKubectlScriptActions?: outputs.DeploymentProcessStepRunKubectlScriptAction[];
    runScriptActions?: outputs.DeploymentProcessStepRunScriptAction[];
    /**
     * Whether to run this step after the previous step ('StartAfterPrevious') or at the same time as the previous step ('StartWithPrevious')
     */
    startTrigger?: string;
    /**
     * The roles that this step run against, or runs on behalf of
     */
    targetRoles: string[];
    /**
     * The maximum number of targets to deploy to simultaneously
     */
    windowSize?: string;
}

export interface DeploymentProcessStepAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate: outputs.DeploymentProcessStepActionActionTemplate;
    /**
     * The type of action
     */
    actionType: string;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers: outputs.DeploymentProcessStepActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency: outputs.DeploymentProcessStepActionGitDependency;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages: outputs.DeploymentProcessStepActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage: outputs.DeploymentProcessStepActionPrimaryPackage;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface DeploymentProcessStepActionActionTemplate {
    communityActionTemplateId: string;
    /**
     * The ID of this resource.
     */
    id: string;
    version: number;
}

export interface DeploymentProcessStepActionContainer {
    feedId?: string;
    image?: string;
}

export interface DeploymentProcessStepActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface DeploymentProcessStepActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * Whether to extract the package during deployment
     */
    extractDuringDeployment: boolean;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepApplyTerraformTemplateAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate: outputs.DeploymentProcessStepApplyTerraformTemplateActionActionTemplate;
    advancedOptions: outputs.DeploymentProcessStepApplyTerraformTemplateActionAdvancedOptions;
    /**
     * (see below for nested schema)
     */
    awsAccount?: outputs.DeploymentProcessStepApplyTerraformTemplateActionAwsAccount;
    /**
     * (see below for nested schema)
     */
    azureAccount?: outputs.DeploymentProcessStepApplyTerraformTemplateActionAzureAccount;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers: outputs.DeploymentProcessStepApplyTerraformTemplateActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency: outputs.DeploymentProcessStepApplyTerraformTemplateActionGitDependency;
    /**
     * (see below for nested schema)
     */
    googleCloudAccount?: outputs.DeploymentProcessStepApplyTerraformTemplateActionGoogleCloudAccount;
    /**
     * The ID of this resource.
     */
    id: string;
    inlineTemplate?: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages: outputs.DeploymentProcessStepApplyTerraformTemplateActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage: outputs.DeploymentProcessStepApplyTerraformTemplateActionPrimaryPackage;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * (see below for nested schema)
     */
    template?: outputs.DeploymentProcessStepApplyTerraformTemplateActionTemplate;
    templateParameters?: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionActionTemplate {
    communityActionTemplateId: string;
    /**
     * The ID of this resource.
     */
    id: string;
    version: number;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionAdvancedOptions {
    allowAdditionalPluginDownloads?: boolean;
    applyParameters?: string;
    initParameters?: string;
    pluginCacheDirectory?: string;
    workspace?: string;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionAwsAccount {
    region?: string;
    /**
     * (see below for nested schema)
     */
    role?: outputs.DeploymentProcessStepApplyTerraformTemplateActionAwsAccountRole;
    useInstanceRole?: boolean;
    variable?: string;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionAwsAccountRole {
    arn?: string;
    externalId?: string;
    roleSessionName?: string;
    sessionDuration?: number;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionAzureAccount {
    variable?: string;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionContainer {
    feedId?: string;
    image?: string;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionGoogleCloudAccount {
    /**
     * Impersonate service accounts
     */
    impersonateServiceAccount?: boolean;
    /**
     * This sets GOOGLE_PROJECT environment variable
     */
    project?: string;
    /**
     * This sets GOOGLE_REGION environment variable
     */
    region?: string;
    /**
     * This sets GOOGLE*IMPERSONATE*SERVICE_ACCOUNT environment variable
     */
    serviceAccountEmails?: string;
    /**
     * When running in a Compute Engine virtual machine, use the associated VM service account
     */
    useVmServiceAccount?: boolean;
    variable?: string;
    /**
     * This sets GOOGLE_ZONE environment variable
     */
    zone?: string;
}

export interface DeploymentProcessStepApplyTerraformTemplateActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepApplyTerraformTemplateActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepApplyTerraformTemplateActionTemplate {
    additionalVariableFiles?: string;
    directory?: string;
    runAutomaticFileSubstitution?: boolean;
    targetFiles?: string;
}

export interface DeploymentProcessStepDeployKubernetesSecretAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate: outputs.DeploymentProcessStepDeployKubernetesSecretActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers: outputs.DeploymentProcessStepDeployKubernetesSecretActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency: outputs.DeploymentProcessStepDeployKubernetesSecretActionGitDependency;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * Indicates the status of the Kubernetes Object Status feature
     */
    kubernetesObjectStatusCheckEnabled?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages: outputs.DeploymentProcessStepDeployKubernetesSecretActionPackage[];
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    /**
     * The name of the secret resource
     */
    secretName: string;
    secretValues: {[key: string]: string};
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface DeploymentProcessStepDeployKubernetesSecretActionActionTemplate {
    communityActionTemplateId: string;
    /**
     * The ID of this resource.
     */
    id: string;
    version: number;
}

export interface DeploymentProcessStepDeployKubernetesSecretActionContainer {
    feedId?: string;
    image?: string;
}

export interface DeploymentProcessStepDeployKubernetesSecretActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface DeploymentProcessStepDeployKubernetesSecretActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepDeployPackageAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate: outputs.DeploymentProcessStepDeployPackageActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers: outputs.DeploymentProcessStepDeployPackageActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency: outputs.DeploymentProcessStepDeployPackageActionGitDependency;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages: outputs.DeploymentProcessStepDeployPackageActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage: outputs.DeploymentProcessStepDeployPackageActionPrimaryPackage;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * Deploy a windows service feature
     */
    windowsService?: outputs.DeploymentProcessStepDeployPackageActionWindowsService;
}

export interface DeploymentProcessStepDeployPackageActionActionTemplate {
    communityActionTemplateId: string;
    /**
     * The ID of this resource.
     */
    id: string;
    version: number;
}

export interface DeploymentProcessStepDeployPackageActionContainer {
    feedId?: string;
    image?: string;
}

export interface DeploymentProcessStepDeployPackageActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface DeploymentProcessStepDeployPackageActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepDeployPackageActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepDeployPackageActionWindowsService {
    /**
     * The command line arguments that will be passed to the service when it starts
     */
    arguments?: string;
    createOrUpdateService: boolean;
    /**
     * The Windows/domain account of the custom user that the service will run under
     */
    customAccountName?: string;
    /**
     * The password for the custom account
     */
    customAccountPassword: string;
    /**
     * Any dependencies that the service has. Separate the names using forward slashes (/).
     */
    dependencies?: string;
    /**
     * User-friendly description of the service (optional)
     */
    description?: string;
    /**
     * The display name of the service (optional)
     */
    displayName?: string;
    /**
     * The path to the executable relative to the package installation directory
     */
    executablePath: string;
    /**
     * Which built-in account will the service run under. Can be LocalSystem, NT Authority\NetworkService, NT Authority\LocalService, _CUSTOM or an expression
     */
    serviceAccount?: string;
    /**
     * The name of the service
     */
    serviceName: string;
    /**
     * When will the service start. Can be auto, delayed-auto, manual, unchanged or an expression
     */
    startMode?: string;
}

export interface DeploymentProcessStepDeployWindowsServiceAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate: outputs.DeploymentProcessStepDeployWindowsServiceActionActionTemplate;
    /**
     * The command line arguments that will be passed to the service when it starts
     */
    arguments?: string;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers: outputs.DeploymentProcessStepDeployWindowsServiceActionContainer[];
    createOrUpdateService: boolean;
    /**
     * The Windows/domain account of the custom user that the service will run under
     */
    customAccountName?: string;
    /**
     * The password for the custom account
     */
    customAccountPassword: string;
    /**
     * Any dependencies that the service has. Separate the names using forward slashes (/).
     */
    dependencies?: string;
    /**
     * User-friendly description of the service (optional)
     */
    description?: string;
    /**
     * The display name of the service (optional)
     */
    displayName?: string;
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * The path to the executable relative to the package installation directory
     */
    executablePath: string;
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency: outputs.DeploymentProcessStepDeployWindowsServiceActionGitDependency;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages: outputs.DeploymentProcessStepDeployWindowsServiceActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage: outputs.DeploymentProcessStepDeployWindowsServiceActionPrimaryPackage;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
    /**
     * Which built-in account will the service run under. Can be LocalSystem, NT Authority\NetworkService, NT Authority\LocalService, _CUSTOM or an expression
     */
    serviceAccount?: string;
    /**
     * The name of the service
     */
    serviceName: string;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * When will the service start. Can be auto, delayed-auto, manual, unchanged or an expression
     */
    startMode?: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
}

export interface DeploymentProcessStepDeployWindowsServiceActionActionTemplate {
    communityActionTemplateId: string;
    /**
     * The ID of this resource.
     */
    id: string;
    version: number;
}

export interface DeploymentProcessStepDeployWindowsServiceActionContainer {
    feedId?: string;
    image?: string;
}

export interface DeploymentProcessStepDeployWindowsServiceActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface DeploymentProcessStepDeployWindowsServiceActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepDeployWindowsServiceActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepManualInterventionAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate: outputs.DeploymentProcessStepManualInterventionActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers: outputs.DeploymentProcessStepManualInterventionActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency: outputs.DeploymentProcessStepManualInterventionActionGitDependency;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The instructions for the user to follow
     */
    instructions: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages: outputs.DeploymentProcessStepManualInterventionActionPackage[];
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
    /**
     * The teams responsible to resolve this step. If no teams are specified, all users who have permission to deploy the project can resolve it.
     */
    responsibleTeams?: string;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
}

export interface DeploymentProcessStepManualInterventionActionActionTemplate {
    communityActionTemplateId: string;
    /**
     * The ID of this resource.
     */
    id: string;
    version: number;
}

export interface DeploymentProcessStepManualInterventionActionContainer {
    feedId?: string;
    image?: string;
}

export interface DeploymentProcessStepManualInterventionActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface DeploymentProcessStepManualInterventionActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepRunKubectlScriptAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate: outputs.DeploymentProcessStepRunKubectlScriptActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers: outputs.DeploymentProcessStepRunKubectlScriptActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency: outputs.DeploymentProcessStepRunKubectlScriptActionGitDependency;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    namespace?: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages: outputs.DeploymentProcessStepRunKubectlScriptActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage: outputs.DeploymentProcessStepRunKubectlScriptActionPrimaryPackage;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    scriptBody?: string;
    /**
     * The script file name in the package
     */
    scriptFileName?: string;
    /**
     * Parameters expected by the script. Use platform specific calling convention. e.g. -Path #{VariableStoringPath} for PowerShell or -- #{VariableStoringPath} for ScriptCS
     */
    scriptParameters?: string;
    scriptSource: string;
    scriptSyntax: string;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * A newline-separated list of file names to transform, relative to the package contents. Extended wildcard syntax is supported.
     */
    variableSubstitutionInFiles?: string;
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface DeploymentProcessStepRunKubectlScriptActionActionTemplate {
    communityActionTemplateId: string;
    /**
     * The ID of this resource.
     */
    id: string;
    version: number;
}

export interface DeploymentProcessStepRunKubectlScriptActionContainer {
    feedId?: string;
    image?: string;
}

export interface DeploymentProcessStepRunKubectlScriptActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface DeploymentProcessStepRunKubectlScriptActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * Whether to extract the package during deployment
     */
    extractDuringDeployment: boolean;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepRunKubectlScriptActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepRunScriptAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate: outputs.DeploymentProcessStepRunScriptActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers: outputs.DeploymentProcessStepRunScriptActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency: outputs.DeploymentProcessStepRunScriptActionGitDependency;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages: outputs.DeploymentProcessStepRunScriptActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage: outputs.DeploymentProcessStepRunScriptActionPrimaryPackage;
    /**
     * A list of properties associated with this package.
     *
     * @deprecated This attribute is deprecated and will be removed in a future release. Please use the attributes that match the properties that are stored to this map.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    scriptBody?: string;
    /**
     * The script file name in the package
     */
    scriptFileName?: string;
    /**
     * Parameters expected by the script. Use platform specific calling convention. e.g. -Path #{VariableStoringPath} for PowerShell or -- #{VariableStoringPath} for ScriptCS
     */
    scriptParameters?: string;
    scriptSource: string;
    scriptSyntax: string;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * A newline-separated list of file names to transform, relative to the package contents. Extended wildcard syntax is supported.
     */
    variableSubstitutionInFiles?: string;
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface DeploymentProcessStepRunScriptActionActionTemplate {
    communityActionTemplateId: string;
    /**
     * The ID of this resource.
     */
    id: string;
    version: number;
}

export interface DeploymentProcessStepRunScriptActionContainer {
    feedId?: string;
    image?: string;
}

export interface DeploymentProcessStepRunScriptActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface DeploymentProcessStepRunScriptActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * Whether to extract the package during deployment
     */
    extractDuringDeployment: boolean;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface DeploymentProcessStepRunScriptActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface ExternalFeedCreateReleaseTriggerPackage {
    deploymentActionSlug: string;
    packageReference: string;
}

export interface ExternalFeedCreateReleaseTriggerPrimaryPackage {
    deploymentActionSlug: string;
}

export interface GetAccountsAccount {
    /**
     * The access key associated with this resource.
     */
    accessKey: string;
    /**
     * Specifies the type of the account. Valid account types are `AmazonWebServicesAccount`, `AmazonWebServicesRoleAccount`, `AzureServicePrincipal`, `AzureOIDC`, `AzureSubscription`, `AmazonWebServicesOidcAccount`, `None`, `SshKeyPair`, `Token`, or `UsernamePassword`.
     */
    accountType: string;
    activeDirectoryEndpointBaseUri: string;
    /**
     * The application ID of this resource.
     */
    applicationId: string;
    /**
     * The authentication endpoint URI for this resource.
     */
    authenticationEndpoint: string;
    /**
     * The Azure environment associated with this resource. Valid Azure environments are `AzureCloud`, `AzureChinaCloud`, `AzureGermanCloud`, or `AzureUSGovernment`.
     */
    azureEnvironment: string;
    certificateData: string;
    certificateThumbprint: string;
    clientSecret: string;
    /**
     * The description of this account resource.
     */
    description: string;
    /**
     * A list of environment IDs associated with this resource.
     */
    environments: string[];
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The password associated with this resource.
     */
    password: string;
    privateKeyFile: string;
    privateKeyPassphrase: string;
    /**
     * The resource manager endpoint URI for this resource.
     */
    resourceManagerEndpoint: string;
    /**
     * The secret key associated with this resource.
     */
    secretKey: string;
    serviceManagementEndpointBaseUri: string;
    serviceManagementEndpointSuffix: string;
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
    /**
     * The subscription ID of this resource.
     */
    subscriptionId: string;
    /**
     * The tenant ID of this resource.
     */
    tenantId: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The tenanted deployment mode of the resource. Valid account types are `Untenanted`, `TenantedOrUntenanted`, or `Tenanted`.
     */
    tenantedDeploymentParticipation: string;
    /**
     * A list of tenant IDs associated with this resource.
     */
    tenants: string[];
    /**
     * The token of this resource.
     */
    token: string;
    /**
     * The username associated with this resource.
     */
    username: string;
}

export interface GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTarget {
    accountId: string;
    cloudServiceName: string;
    defaultWorkerPoolId: string;
    endpoints: outputs.GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpoint[];
    /**
     * A list of environment IDs associated with this resource.
     */
    environments: string[];
    hasLatestCalamari: boolean;
    /**
     * Represents the health status of this deployment target. Valid health statuses are `HasWarnings`, `Healthy`, `Unavailable`, `Unhealthy`, or `Unknown`.
     */
    healthStatus: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    /**
     * The name of this resource.
     */
    name: string;
    operatingSystem: string;
    roles: string[];
    shellName: string;
    shellVersion: string;
    slot: string;
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
    /**
     * The status of this resource. Valid statuses are `CalamariNeedsUpgrade`, `Disabled`, `NeedsUpgrade`, `Offline`, `Online`, or `Unknown`.
     */
    status: string;
    /**
     * A summary elaborating on the status of this resource.
     */
    statusSummary: string;
    storageAccountName: string;
    swapIfPossible: boolean;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The tenanted deployment mode of the resource. Valid account types are `Untenanted`, `TenantedOrUntenanted`, or `Tenanted`.
     */
    tenantedDeploymentParticipation: string;
    /**
     * A list of tenant IDs associated with this resource.
     */
    tenants: string[];
    thumbprint: string;
    uri: string;
    useCurrentInstanceCount: boolean;
}

export interface GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface GetAzureCloudServiceDeploymentTargetsAzureCloudServiceDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTarget {
    aadClientCredentialSecret: string;
    aadCredentialType: string;
    aadUserCredentialPassword: string;
    aadUserCredentialUsername: string;
    certificateStoreLocation: string;
    certificateStoreName: string;
    clientCertificateVariable: string;
    connectionEndpoint: string;
    endpoints: outputs.GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpoint[];
    /**
     * A list of environment IDs associated with this resource.
     */
    environments: string[];
    hasLatestCalamari: boolean;
    /**
     * Represents the health status of this deployment target. Valid health statuses are `HasWarnings`, `Healthy`, `Unavailable`, `Unhealthy`, or `Unknown`.
     */
    healthStatus: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    /**
     * The name of this resource.
     */
    name: string;
    operatingSystem: string;
    roles: string[];
    securityMode: string;
    serverCertificateThumbprint: string;
    shellName: string;
    shellVersion: string;
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
    /**
     * The status of this resource. Valid statuses are `CalamariNeedsUpgrade`, `Disabled`, `NeedsUpgrade`, `Offline`, `Online`, or `Unknown`.
     */
    status: string;
    /**
     * A summary elaborating on the status of this resource.
     */
    statusSummary: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The tenanted deployment mode of the resource. Valid account types are `Untenanted`, `TenantedOrUntenanted`, or `Tenanted`.
     */
    tenantedDeploymentParticipation: string;
    /**
     * A list of tenant IDs associated with this resource.
     */
    tenants: string[];
    thumbprint: string;
    uri: string;
}

export interface GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface GetAzureServiceFabricClusterDeploymentTargetsAzureServiceFabricClusterDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTarget {
    accountId: string;
    endpoints: outputs.GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpoint[];
    /**
     * A list of environment IDs associated with this resource.
     */
    environments: string[];
    hasLatestCalamari: boolean;
    /**
     * Represents the health status of this deployment target. Valid health statuses are `HasWarnings`, `Healthy`, `Unavailable`, `Unhealthy`, or `Unknown`.
     */
    healthStatus: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    /**
     * The name of this resource.
     */
    name: string;
    operatingSystem: string;
    resourceGroupName: string;
    roles: string[];
    shellName: string;
    shellVersion: string;
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
    /**
     * The status of this resource. Valid statuses are `CalamariNeedsUpgrade`, `Disabled`, `NeedsUpgrade`, `Offline`, `Online`, or `Unknown`.
     */
    status: string;
    /**
     * A summary elaborating on the status of this resource.
     */
    statusSummary: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The tenanted deployment mode of the resource. Valid account types are `Untenanted`, `TenantedOrUntenanted`, or `Tenanted`.
     */
    tenantedDeploymentParticipation: string;
    /**
     * A list of tenant IDs associated with this resource.
     */
    tenants: string[];
    thumbprint: string;
    uri: string;
    webAppName: string;
    webAppSlotName: string;
}

export interface GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface GetAzureWebAppDeploymentTargetsAzureWebAppDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetCertificatesCertificate {
    archived: string;
    /**
     * The encoded data of the certificate.
     */
    certificateData: string;
    /**
     * Specifies the archive file format used for storing cryptography objects in the certificate. Valid formats are `Der`, `Pem`, `Pkcs12`, or `Unknown`.
     */
    certificateDataFormat: string;
    /**
     * A list of environment IDs associated with this resource.
     */
    environments: string[];
    /**
     * Indicates if the certificate has a private key.
     */
    hasPrivateKey: boolean;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Indicates if the certificate has expired.
     */
    isExpired: boolean;
    issuerCommonName: string;
    issuerDistinguishedName: string;
    issuerOrganization: string;
    /**
     * The name of this resource.
     */
    name: string;
    notAfter: string;
    notBefore: string;
    notes: string;
    /**
     * The password associated with this resource.
     */
    password: string;
    replacedBy: string;
    selfSigned: boolean;
    serialNumber: string;
    signatureAlgorithmName: string;
    spaceId: string;
    subjectAlternativeNames: string[];
    subjectCommonName: string;
    subjectDistinguishedName: string;
    subjectOrganization: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The tenanted deployment mode of the resource. Valid account types are `Untenanted`, `TenantedOrUntenanted`, or `Tenanted`.
     */
    tenantedDeploymentParticipation: string;
    /**
     * A list of tenant IDs associated with this resource.
     */
    tenants: string[];
    thumbprint: string;
    version: number;
}

export interface GetChannelsChannel {
    /**
     * The description of this channel.
     */
    description: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Indicates if this is the default channel for the associated project.
     */
    isDefault: boolean;
    /**
     * The lifecycle ID associated with this channel.
     */
    lifecycleId: string;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The project ID associated with this channel.
     */
    projectId: string;
    /**
     * A list of rules associated with this channel.
     */
    rules: outputs.GetChannelsChannelRule[];
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
}

export interface GetChannelsChannelRule {
    actionPackages: outputs.GetChannelsChannelRuleActionPackage[];
    /**
     * The unique ID for this resource.
     */
    id: string;
    tag?: string;
    versionRange?: string;
}

export interface GetChannelsChannelRuleActionPackage {
    deploymentAction?: string;
    packageReference?: string;
}

export interface GetCloudRegionDeploymentTargetsCloudRegionDeploymentTarget {
    defaultWorkerPoolId: string;
    endpoints: outputs.GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpoint[];
    /**
     * A list of environment IDs associated with this resource.
     */
    environments: string[];
    hasLatestCalamari: boolean;
    /**
     * Represents the health status of this deployment target. Valid health statuses are `HasWarnings`, `Healthy`, `Unavailable`, `Unhealthy`, or `Unknown`.
     */
    healthStatus: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    /**
     * The name of this resource.
     */
    name: string;
    operatingSystem: string;
    roles: string[];
    shellName: string;
    shellVersion: string;
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
    /**
     * The status of this resource. Valid statuses are `CalamariNeedsUpgrade`, `Disabled`, `NeedsUpgrade`, `Offline`, `Online`, or `Unknown`.
     */
    status: string;
    /**
     * A summary elaborating on the status of this resource.
     */
    statusSummary: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The tenanted deployment mode of the resource. Valid account types are `Untenanted`, `TenantedOrUntenanted`, or `Tenanted`.
     */
    tenantedDeploymentParticipation: string;
    /**
     * A list of tenant IDs associated with this resource.
     */
    tenants: string[];
    thumbprint: string;
    uri: string;
}

export interface GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface GetCloudRegionDeploymentTargetsCloudRegionDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetDeploymentTargetsDeploymentTarget {
    endpoints: outputs.GetDeploymentTargetsDeploymentTargetEndpoint[];
    /**
     * A list of environment IDs associated with this resource.
     */
    environments: string[];
    hasLatestCalamari: boolean;
    /**
     * Represents the health status of this deployment target. Valid health statuses are `HasWarnings`, `Healthy`, `Unavailable`, `Unhealthy`, or `Unknown`.
     */
    healthStatus: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    /**
     * The name of this resource.
     */
    name: string;
    operatingSystem: string;
    roles: string[];
    shellName: string;
    shellVersion: string;
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
    /**
     * The status of this resource. Valid statuses are `CalamariNeedsUpgrade`, `Disabled`, `NeedsUpgrade`, `Offline`, `Online`, or `Unknown`.
     */
    status: string;
    /**
     * A summary elaborating on the status of this resource.
     */
    statusSummary: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The tenanted deployment mode of the resource. Valid account types are `Untenanted`, `TenantedOrUntenanted`, or `Tenanted`.
     */
    tenantedDeploymentParticipation: string;
    /**
     * A list of tenant IDs associated with this resource.
     */
    tenants: string[];
    thumbprint: string;
    uri: string;
}

export interface GetDeploymentTargetsDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.GetDeploymentTargetsDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.GetDeploymentTargetsDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.GetDeploymentTargetsDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.GetDeploymentTargetsDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface GetDeploymentTargetsDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface GetDeploymentTargetsDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface GetDeploymentTargetsDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface GetDeploymentTargetsDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetKubernetesAgentDeploymentTargetsKubernetesAgentDeploymentTarget {
    /**
     * Name of the Helm release that the agent belongs to.
     */
    agentHelmReleaseName: string;
    /**
     * Name of the Kubernetes namespace where the agent is installed.
     */
    agentKubernetesNamespace: string;
    /**
     * Current Tentacle version of the agent
     */
    agentTentacleVersion: string;
    /**
     * Current upgrade availability status of the agent. One of 'NoUpgrades', 'UpgradeAvailable', 'UpgradeSuggested', 'UpgradeRequired'
     */
    agentUpgradeStatus: string;
    /**
     * Current Helm chart version of the agent.
     */
    agentVersion: string;
    /**
     * The communication mode used by the Kubernetes agent to communicate with Octopus Server. Currently, the only supported value is 'Polling'.
     */
    communicationMode: string;
    /**
     * Optional default namespace that will be used when using Kubernetes deployment steps, can be overrides within step configurations.
     */
    defaultNamespace: string;
    /**
     * A list of environment IDs this Kubernetes agent can deploy to.
     */
    environments: string[];
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Whether the Kubernetes agent is disabled. If the agent is disabled, it will not be included in any deployments.
     */
    isDisabled: boolean;
    /**
     * Optional ID of the machine policy that the Kubernetes agent will use. If not provided the default machine policy will be used.
     */
    machinePolicyId: string;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * A list of target roles that are associated to this Kubernetes agent.
     */
    roles: string[];
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The tenanted deployment mode of the resource. Valid account types are `Untenanted`, `TenantedOrUntenanted`, or `Tenanted`.
     */
    tenantedDeploymentParticipation: string;
    /**
     * A list of tenant IDs associated with this resource.
     */
    tenants: string[];
    /**
     * The thumbprint of the Kubernetes agent's certificate used by server to verify the identity of the agent. This is the same thumbprint that was used when installing the agent.
     */
    thumbprint: string;
    /**
     * If enabled the Kubernetes agent will not automatically upgrade and will stay on the currently installed version, even if the associated machine policy is configured to automatically upgrade.
     */
    upgradeLocked: boolean;
    /**
     * The URI of the Kubernetes agent's used by the server to queue messages. This is the same subscription uri that was used when installing the agent.
     */
    uri: string;
}

export interface GetKubernetesAgentWorkersKubernetesAgentWorker {
    /**
     * Name of the Helm release that the agent belongs to.
     */
    agentHelmReleaseName: string;
    /**
     * Name of the Kubernetes namespace where the agent is installed.
     */
    agentKubernetesNamespace: string;
    /**
     * Current Tentacle version of the agent
     */
    agentTentacleVersion: string;
    /**
     * Current upgrade availability status of the agent. One of 'NoUpgrades', 'UpgradeAvailable', 'UpgradeSuggested', 'UpgradeRequired'
     */
    agentUpgradeStatus: string;
    /**
     * Current Helm chart version of the agent.
     */
    agentVersion: string;
    /**
     * The communication mode used by the Kubernetes agent to communicate with Octopus Server. Currently, the only supported value is 'Polling'.
     */
    communicationMode: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Whether the Kubernetes agent is disabled. If the agent is disabled, it will not be included in any deployments.
     */
    isDisabled: boolean;
    /**
     * Optional ID of the machine policy that the Kubernetes agent will use. If not provided the default machine policy will be used.
     */
    machinePolicyId: string;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
    /**
     * The thumbprint of the Kubernetes agent's certificate used by server to verify the identity of the agent. This is the same thumbprint that was used when installing the agent.
     */
    thumbprint: string;
    /**
     * If enabled the Kubernetes agent will not automatically upgrade and will stay on the currently installed version, even if the associated machine policy is configured to automatically upgrade.
     */
    upgradeLocked: boolean;
    /**
     * The URI of the Kubernetes agent's used by the server to queue messages. This is the same subscription uri that was used when installing the agent.
     */
    uri: string;
    /**
     * A list of worker pool Ids specifying the pools in which this worker belongs
     */
    workerPoolIds: string[];
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTarget {
    authentications: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetAuthentication[];
    awsAccountAuthentications: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetAwsAccountAuthentication[];
    azureServicePrincipalAuthentications: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetAzureServicePrincipalAuthentication[];
    certificateAuthentications: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetCertificateAuthentication[];
    clusterCertificate: string;
    clusterCertificatePath: string;
    clusterUrl: string;
    containerOptions: string;
    containers: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetContainer[];
    defaultWorkerPoolId: string;
    endpoints: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpoint[];
    /**
     * A list of environment IDs associated with this resource.
     */
    environments: string[];
    gcpAccountAuthentications: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetGcpAccountAuthentication[];
    hasLatestCalamari: boolean;
    /**
     * Represents the health status of this deployment target. Valid health statuses are `HasWarnings`, `Healthy`, `Unavailable`, `Unhealthy`, or `Unknown`.
     */
    healthStatus: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    /**
     * The name of this resource.
     */
    name: string;
    namespace: string;
    operatingSystem: string;
    podAuthentications: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetPodAuthentication[];
    proxyId: string;
    roles: string[];
    runningInContainer: boolean;
    shellName: string;
    shellVersion: string;
    skipTlsVerification: boolean;
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
    /**
     * The status of this resource. Valid statuses are `CalamariNeedsUpgrade`, `Disabled`, `NeedsUpgrade`, `Offline`, `Online`, or `Unknown`.
     */
    status: string;
    /**
     * A summary elaborating on the status of this resource.
     */
    statusSummary: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The tenanted deployment mode of the resource. Valid account types are `Untenanted`, `TenantedOrUntenanted`, or `Tenanted`.
     */
    tenantedDeploymentParticipation: string;
    /**
     * A list of tenant IDs associated with this resource.
     */
    tenants: string[];
    thumbprint: string;
    uri: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetAuthentication {
    accountId?: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetAwsAccountAuthentication {
    accountId: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    clusterName: string;
    useInstanceRole?: boolean;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetAzureServicePrincipalAuthentication {
    accountId: string;
    clusterName: string;
    clusterResourceGroup: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetCertificateAuthentication {
    clientCertificate?: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetContainer {
    feedId?: string;
    image?: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetGcpAccountAuthentication {
    accountId: string;
    clusterName: string;
    impersonateServiceAccount?: boolean;
    project: string;
    region?: string;
    serviceAccountEmails?: string;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface GetKubernetesClusterDeploymentTargetsKubernetesClusterDeploymentTargetPodAuthentication {
    tokenPath: string;
}

export interface GetListeningTentacleDeploymentTargetsListeningTentacleDeploymentTarget {
    certificateSignatureAlgorithm: string;
    /**
     * A list of environment IDs associated with this listening tentacle.
     */
    environments: string[];
    hasLatestCalamari: boolean;
    /**
     * Represents the health status of this deployment target. Valid health statuses are `HasWarnings`, `Healthy`, `Unavailable`, `Unhealthy`, or `Unknown`.
     */
    healthStatus: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * Represents the disabled status of this deployment target.
     */
    isDisabled: boolean;
    /**
     * Represents the in-process status of this deployment target.
     */
    isInProcess: boolean;
    /**
     * The machine policy ID that is associated with this deployment target.
     */
    machinePolicyId: string;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The operating system that is associated with this deployment target.
     */
    operatingSystem: string;
    /**
     * The proxy ID that is associated with this deployment target.
     */
    proxyId: string;
    /**
     * A list of role IDs that are associated with this deployment target.
     */
    roles: string[];
    /**
     * The shell name associated with this deployment target.
     */
    shellName: string;
    /**
     * The shell version associated with this deployment target.
     */
    shellVersion: string;
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
    /**
     * The status of this resource. Valid statuses are `CalamariNeedsUpgrade`, `Disabled`, `NeedsUpgrade`, `Offline`, `Online`, or `Unknown`.
     */
    status: string;
    /**
     * A summary elaborating on the status of this resource.
     */
    statusSummary: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The tenanted deployment mode of the resource. Valid account types are `Untenanted`, `TenantedOrUntenanted`, or `Tenanted`.
     */
    tenantedDeploymentParticipation: string;
    /**
     * A list of tenant IDs associated with this resource.
     */
    tenants: string[];
    /**
     * The tenant URL of this deployment target.
     */
    tentacleUrl: string;
    tentacleVersionDetails: outputs.GetListeningTentacleDeploymentTargetsListeningTentacleDeploymentTargetTentacleVersionDetail[];
    /**
     * The thumbprint of this deployment target.
     */
    thumbprint: string;
    /**
     * The URI of this deployment target.
     */
    uri: string;
}

export interface GetListeningTentacleDeploymentTargetsListeningTentacleDeploymentTargetTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetMachinePoliciesMachinePolicy {
    /**
     * In nanoseconds. Minimum value: 10000000000 (10 seconds).
     */
    connectionConnectTimeout: number;
    connectionRetryCountLimit: number;
    /**
     * In nanoseconds.
     */
    connectionRetrySleepInterval: number;
    /**
     * In nanoseconds.
     */
    connectionRetryTimeLimit: number;
    /**
     * The description of this machine policy.
     */
    description: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    isDefault: boolean;
    machineCleanupPolicies: outputs.GetMachinePoliciesMachinePolicyMachineCleanupPolicy[];
    machineConnectivityPolicies: outputs.GetMachinePoliciesMachinePolicyMachineConnectivityPolicy[];
    machineHealthCheckPolicies: outputs.GetMachinePoliciesMachinePolicyMachineHealthCheckPolicy[];
    machineUpdatePolicies: outputs.GetMachinePoliciesMachinePolicyMachineUpdatePolicy[];
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * In nanoseconds.
     */
    pollingRequestQueueTimeout: number;
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
}

export interface GetMachinePoliciesMachinePolicyMachineCleanupPolicy {
    deleteMachinesBehavior?: string;
    /**
     * In nanoseconds.
     */
    deleteMachinesElapsedTimespan: number;
}

export interface GetMachinePoliciesMachinePolicyMachineConnectivityPolicy {
    machineConnectivityBehavior?: string;
}

export interface GetMachinePoliciesMachinePolicyMachineHealthCheckPolicy {
    bashHealthCheckPolicy: outputs.GetMachinePoliciesMachinePolicyMachineHealthCheckPolicyBashHealthCheckPolicy;
    healthCheckCron?: string;
    healthCheckCronTimezone?: string;
    /**
     * In nanoseconds.
     */
    healthCheckInterval?: number;
    healthCheckType?: string;
    powershellHealthCheckPolicy: outputs.GetMachinePoliciesMachinePolicyMachineHealthCheckPolicyPowershellHealthCheckPolicy;
}

export interface GetMachinePoliciesMachinePolicyMachineHealthCheckPolicyBashHealthCheckPolicy {
    runType?: string;
    scriptBody?: string;
}

export interface GetMachinePoliciesMachinePolicyMachineHealthCheckPolicyPowershellHealthCheckPolicy {
    runType?: string;
    scriptBody?: string;
}

export interface GetMachinePoliciesMachinePolicyMachineUpdatePolicy {
    /**
     * The behaviour of how Calamari is updated. Valid values are `UpdateAlways`, `UpdateOnDeployment` and `UpdateOnNewMachine`.
     */
    calamariUpdateBehavior?: string;
    /**
     * The behaviour of how Kubernetes agent machines are updated. Valid values are `NeverUpdate` and `Update`.
     */
    kubernetesAgentUpdateBehavior?: string;
    /**
     * The Account ID to perform any Tentacle updates under.
     */
    tentacleUpdateAccountId?: string;
    /**
     * The behaviour of how Tentacle machines are updated. Valid values are `NeverUpdate` and `Update`.
     */
    tentacleUpdateBehavior?: string;
}

export interface GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTarget {
    applicationsDirectory: string;
    destinations: outputs.GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetDestination[];
    endpoints: outputs.GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpoint[];
    /**
     * A list of environment IDs associated with this resource.
     */
    environments: string[];
    hasLatestCalamari: boolean;
    /**
     * Represents the health status of this deployment target. Valid health statuses are `HasWarnings`, `Healthy`, `Unavailable`, `Unhealthy`, or `Unknown`.
     */
    healthStatus: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    /**
     * The name of this resource.
     */
    name: string;
    operatingSystem: string;
    roles: string[];
    shellName: string;
    shellVersion: string;
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
    /**
     * The status of this resource. Valid statuses are `CalamariNeedsUpgrade`, `Disabled`, `NeedsUpgrade`, `Offline`, `Online`, or `Unknown`.
     */
    status: string;
    /**
     * A summary elaborating on the status of this resource.
     */
    statusSummary: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The tenanted deployment mode of the resource. Valid account types are `Untenanted`, `TenantedOrUntenanted`, or `Tenanted`.
     */
    tenantedDeploymentParticipation: string;
    /**
     * A list of tenant IDs associated with this resource.
     */
    tenants: string[];
    thumbprint: string;
    uri: string;
    workingDirectory: string;
}

export interface GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface GetOfflinePackageDropDeploymentTargetsOfflinePackageDropDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTarget {
    certificateSignatureAlgorithm: string;
    endpoints: outputs.GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpoint[];
    /**
     * A list of environment IDs associated with this resource.
     */
    environments: string[];
    hasLatestCalamari: boolean;
    /**
     * Represents the health status of this deployment target. Valid health statuses are `HasWarnings`, `Healthy`, `Unavailable`, `Unhealthy`, or `Unknown`.
     */
    healthStatus: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    /**
     * The name of this resource.
     */
    name: string;
    operatingSystem: string;
    roles: string[];
    shellName: string;
    shellVersion: string;
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
    /**
     * The status of this resource. Valid statuses are `CalamariNeedsUpgrade`, `Disabled`, `NeedsUpgrade`, `Offline`, `Online`, or `Unknown`.
     */
    status: string;
    /**
     * A summary elaborating on the status of this resource.
     */
    statusSummary: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The tenanted deployment mode of the resource. Valid account types are `Untenanted`, `TenantedOrUntenanted`, or `Tenanted`.
     */
    tenantedDeploymentParticipation: string;
    /**
     * A list of tenant IDs associated with this resource.
     */
    tenants: string[];
    tentacleUrl: string;
    tentacleVersionDetails: outputs.GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetTentacleVersionDetail[];
    thumbprint: string;
    uri: string;
}

export interface GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetPollingTentacleDeploymentTargetsPollingTentacleDeploymentTargetTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetSshConnectionDeploymentTargetsSshConnectionDeploymentTarget {
    accountId: string;
    dotNetCorePlatform: string;
    endpoints: outputs.GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpoint[];
    /**
     * A list of environment IDs associated with this resource.
     */
    environments: string[];
    fingerprint: string;
    hasLatestCalamari: boolean;
    /**
     * Represents the health status of this deployment target. Valid health statuses are `HasWarnings`, `Healthy`, `Unavailable`, `Unhealthy`, or `Unknown`.
     */
    healthStatus: string;
    host: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    isDisabled: boolean;
    isInProcess: boolean;
    machinePolicyId: string;
    /**
     * The name of this resource.
     */
    name: string;
    operatingSystem: string;
    port: number;
    proxyId: string;
    roles: string[];
    shellName: string;
    shellVersion: string;
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
    /**
     * The status of this resource. Valid statuses are `CalamariNeedsUpgrade`, `Disabled`, `NeedsUpgrade`, `Offline`, `Online`, or `Unknown`.
     */
    status: string;
    /**
     * A summary elaborating on the status of this resource.
     */
    statusSummary: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The tenanted deployment mode of the resource. Valid account types are `Untenanted`, `TenantedOrUntenanted`, or `Tenanted`.
     */
    tenantedDeploymentParticipation: string;
    /**
     * A list of tenant IDs associated with this resource.
     */
    tenants: string[];
    thumbprint: string;
    uri: string;
}

export interface GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface GetSshConnectionDeploymentTargetsSshConnectionDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface GetTeamsTeam {
    canBeDeleted: boolean;
    canBeRenamed: boolean;
    canChangeMembers: boolean;
    canChangeRoles: boolean;
    /**
     * The user-friendly description of this team.
     */
    description: string;
    externalSecurityGroups: outputs.GetTeamsTeamExternalSecurityGroup[];
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this team.
     */
    name: string;
    /**
     * The space associated with this team.
     */
    spaceId: string;
    /**
     * A list of user IDs designated to be members of this team.
     */
    users: string[];
}

export interface GetTeamsTeamExternalSecurityGroup {
    displayIdAndName: boolean;
    displayName: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
}

export interface GetUserRolesUserRole {
    canBeDeleted: boolean;
    /**
     * The description of this user role.
     */
    description: string;
    grantedSpacePermissions: string[];
    grantedSystemPermissions: string[];
    /**
     * The unique ID for this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name: string;
    spacePermissionDescriptions: string[];
    supportedRestrictions: string[];
    systemPermissionDescriptions: string[];
}

export interface GetUsersUser {
    canPasswordBeEdited: boolean;
    /**
     * The display name of this resource.
     */
    displayName: string;
    /**
     * The email address of this resource.
     */
    emailAddress: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    identities: outputs.GetUsersUserIdentity[];
    isActive: boolean;
    isRequestor: boolean;
    isService: boolean;
    /**
     * The password associated with this resource.
     */
    password: string;
    /**
     * The username associated with this resource.
     */
    username: string;
}

export interface GetUsersUserIdentity {
    claims?: outputs.GetUsersUserIdentityClaim[];
    provider?: string;
}

export interface GetUsersUserIdentityClaim {
    isIdentifyingClaim: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    value: string;
}

export interface GetWorkerPoolsWorkerPool {
    canAddWorkers: boolean;
    /**
     * The description of this worker pool.
     */
    description: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    isDefault: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The order number to sort a dynamic worker pool.
     */
    sortOrder: number;
    /**
     * The space ID associated with this resource.
     */
    spaceId: string;
    workerPoolType: string;
    workerType: string;
}

export interface KubernetesClusterDeploymentTargetAuthentication {
    accountId?: string;
}

export interface KubernetesClusterDeploymentTargetAwsAccountAuthentication {
    accountId: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    clusterName: string;
    useInstanceRole?: boolean;
}

export interface KubernetesClusterDeploymentTargetAzureServicePrincipalAuthentication {
    accountId: string;
    clusterName: string;
    clusterResourceGroup: string;
}

export interface KubernetesClusterDeploymentTargetCertificateAuthentication {
    clientCertificate?: string;
}

export interface KubernetesClusterDeploymentTargetContainer {
    feedId?: string;
    image?: string;
}

export interface KubernetesClusterDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.KubernetesClusterDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.KubernetesClusterDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.KubernetesClusterDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.KubernetesClusterDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface KubernetesClusterDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface KubernetesClusterDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface KubernetesClusterDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface KubernetesClusterDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface KubernetesClusterDeploymentTargetGcpAccountAuthentication {
    accountId: string;
    clusterName: string;
    impersonateServiceAccount?: boolean;
    project: string;
    region?: string;
    serviceAccountEmails?: string;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface KubernetesClusterDeploymentTargetPodAuthentication {
    tokenPath: string;
}

export interface ListeningTentacleDeploymentTargetTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface MachinePolicyMachineCleanupPolicy {
    deleteMachinesBehavior?: string;
    /**
     * In nanoseconds.
     */
    deleteMachinesElapsedTimespan: number;
}

export interface MachinePolicyMachineConnectivityPolicy {
    machineConnectivityBehavior?: string;
}

export interface MachinePolicyMachineHealthCheckPolicy {
    bashHealthCheckPolicy: outputs.MachinePolicyMachineHealthCheckPolicyBashHealthCheckPolicy;
    healthCheckCron?: string;
    healthCheckCronTimezone?: string;
    /**
     * In nanoseconds.
     */
    healthCheckInterval?: number;
    healthCheckType?: string;
    powershellHealthCheckPolicy: outputs.MachinePolicyMachineHealthCheckPolicyPowershellHealthCheckPolicy;
}

export interface MachinePolicyMachineHealthCheckPolicyBashHealthCheckPolicy {
    runType?: string;
    scriptBody?: string;
}

export interface MachinePolicyMachineHealthCheckPolicyPowershellHealthCheckPolicy {
    runType?: string;
    scriptBody?: string;
}

export interface MachinePolicyMachineUpdatePolicy {
    /**
     * The behaviour of how Calamari is updated. Valid values are `UpdateAlways`, `UpdateOnDeployment` and `UpdateOnNewMachine`.
     */
    calamariUpdateBehavior?: string;
    /**
     * The behaviour of how Kubernetes agent machines are updated. Valid values are `NeverUpdate` and `Update`.
     */
    kubernetesAgentUpdateBehavior?: string;
    /**
     * The Account ID to perform any Tentacle updates under.
     */
    tentacleUpdateAccountId?: string;
    /**
     * The behaviour of how Tentacle machines are updated. Valid values are `NeverUpdate` and `Update`.
     */
    tentacleUpdateBehavior?: string;
}

export interface OfflinePackageDropDeploymentTargetDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface OfflinePackageDropDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.OfflinePackageDropDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.OfflinePackageDropDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.OfflinePackageDropDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.OfflinePackageDropDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface OfflinePackageDropDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface OfflinePackageDropDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface OfflinePackageDropDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface OfflinePackageDropDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface PollingTentacleDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.PollingTentacleDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.PollingTentacleDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.PollingTentacleDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.PollingTentacleDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface PollingTentacleDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface PollingTentacleDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface PollingTentacleDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface PollingTentacleDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface PollingTentacleDeploymentTargetTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface ProjectScheduledTriggerContinuousDailySchedule {
    /**
     * The days of the week to run the trigger.
     */
    daysOfWeeks: string[];
    /**
     * How often to run the trigger in hours. Only used when the interval is set to 'OnceHourly'.
     */
    hourInterval?: number;
    /**
     * The interval in minutes to run the trigger.
     */
    interval: string;
    /**
     * How often to run the trigger in minutes. Only used when the interval is set to 'OnceEveryMinute'.
     */
    minuteInterval?: number;
    /**
     * The time of day to start the trigger.
     */
    runAfter: string;
    /**
     * The time of day to end the trigger.
     */
    runUntil: string;
}

export interface ProjectScheduledTriggerCronExpressionSchedule {
    /**
     * The cron expression for the schedule.
     */
    cronExpression: string;
}

export interface ProjectScheduledTriggerDaysPerMonthSchedule {
    /**
     * Which date of the month to run the trigger. String number between 1 - 31 Incl. or L for the last day of the month.
     */
    dateOfMonth?: string;
    /**
     * Which ordinal day of the week to run the trigger on. String number between 1 - 4 Incl. or L for the last occurrence of day*of*week for the month.
     */
    dayNumberOfMonth?: string;
    /**
     * Which day of the week to run the trigger on. Required when monthly*schedule*type is set to 'DayOfMonth'.
     */
    dayOfWeek?: string;
    /**
     * The type of monthly schedule to run the trigger
     */
    monthlyScheduleType: string;
    /**
     * The time of day to start the trigger.
     */
    startTime: string;
}

export interface ProjectScheduledTriggerDeployLatestReleaseAction {
    /**
     * The environment ID to deploy the selected release to.
     */
    destinationEnvironmentId: string;
    /**
     * Enable to re-deploy to the deployment targets even if they are already up-to-date with the current deployment.
     */
    shouldRedeploy?: boolean;
    /**
     * The environment ID to use when selecting the release to deploy from.
     */
    sourceEnvironmentId: string;
}

export interface ProjectScheduledTriggerDeployNewReleaseAction {
    /**
     * The environment ID to deploy the selected release to.
     */
    destinationEnvironmentId: string;
    /**
     * The git reference to use when creating the release. Can be a branch, tag, or commit hash.
     */
    gitReference?: string;
}

export interface ProjectScheduledTriggerOnceDailySchedule {
    /**
     * The days of the week to run the trigger.
     */
    daysOfWeeks: string[];
    /**
     * The time of day to start the trigger.
     */
    startTime: string;
}

export interface ProjectScheduledTriggerRunRunbookAction {
    /**
     * The ID of the runbook to run.
     */
    runbookId: string;
    /**
     * The IDs of the environments to run the runbook in.
     */
    targetEnvironmentIds: string[];
}

export interface RunbookProcessStep {
    actions?: outputs.RunbookProcessStepAction[];
    /**
     * (see below for nested schema)
     */
    applyTerraformTemplateActions?: outputs.RunbookProcessStepApplyTerraformTemplateAction[];
    /**
     * When to run the step, one of 'Success', 'Failure', 'Always' or 'Variable'
     */
    condition?: string;
    /**
     * The expression to evaluate to determine whether to run this step when 'condition' is 'Variable'
     */
    conditionExpression: string;
    deployKubernetesSecretActions?: outputs.RunbookProcessStepDeployKubernetesSecretAction[];
    deployPackageActions?: outputs.RunbookProcessStepDeployPackageAction[];
    deployWindowsServiceActions?: outputs.RunbookProcessStepDeployWindowsServiceAction[];
    /**
     * The unique ID for this resource.
     */
    id: string;
    manualInterventionActions?: outputs.RunbookProcessStepManualInterventionAction[];
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * Whether to run this step before or after package acquisition (if possible)
     */
    packageRequirement?: string;
    properties: {[key: string]: any};
    runKubectlScriptActions?: outputs.RunbookProcessStepRunKubectlScriptAction[];
    runScriptActions?: outputs.RunbookProcessStepRunScriptAction[];
    /**
     * Whether to run this step after the previous step ('StartAfterPrevious') or at the same time as the previous step ('StartWithPrevious')
     */
    startTrigger?: string;
    /**
     * The roles that this step run against, or runs on behalf of
     */
    targetRoles: string[];
    /**
     * The maximum number of targets to deploy to simultaneously
     */
    windowSize?: string;
}

export interface RunbookProcessStepAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate: outputs.RunbookProcessStepActionActionTemplate;
    /**
     * The type of action
     */
    actionType: string;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers: outputs.RunbookProcessStepActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency: outputs.RunbookProcessStepActionGitDependency;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages: outputs.RunbookProcessStepActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage: outputs.RunbookProcessStepActionPrimaryPackage;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface RunbookProcessStepActionActionTemplate {
    communityActionTemplateId: string;
    /**
     * The ID of this resource.
     */
    id: string;
    version: number;
}

export interface RunbookProcessStepActionContainer {
    feedId?: string;
    image?: string;
}

export interface RunbookProcessStepActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface RunbookProcessStepActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * Whether to extract the package during deployment
     */
    extractDuringDeployment: boolean;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepApplyTerraformTemplateAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate: outputs.RunbookProcessStepApplyTerraformTemplateActionActionTemplate;
    advancedOptions: outputs.RunbookProcessStepApplyTerraformTemplateActionAdvancedOptions;
    /**
     * (see below for nested schema)
     */
    awsAccount?: outputs.RunbookProcessStepApplyTerraformTemplateActionAwsAccount;
    /**
     * (see below for nested schema)
     */
    azureAccount?: outputs.RunbookProcessStepApplyTerraformTemplateActionAzureAccount;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers: outputs.RunbookProcessStepApplyTerraformTemplateActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency: outputs.RunbookProcessStepApplyTerraformTemplateActionGitDependency;
    /**
     * (see below for nested schema)
     */
    googleCloudAccount?: outputs.RunbookProcessStepApplyTerraformTemplateActionGoogleCloudAccount;
    /**
     * The ID of this resource.
     */
    id: string;
    inlineTemplate?: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages: outputs.RunbookProcessStepApplyTerraformTemplateActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage: outputs.RunbookProcessStepApplyTerraformTemplateActionPrimaryPackage;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * (see below for nested schema)
     */
    template?: outputs.RunbookProcessStepApplyTerraformTemplateActionTemplate;
    templateParameters?: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface RunbookProcessStepApplyTerraformTemplateActionActionTemplate {
    communityActionTemplateId: string;
    /**
     * The ID of this resource.
     */
    id: string;
    version: number;
}

export interface RunbookProcessStepApplyTerraformTemplateActionAdvancedOptions {
    allowAdditionalPluginDownloads?: boolean;
    applyParameters?: string;
    initParameters?: string;
    pluginCacheDirectory?: string;
    workspace?: string;
}

export interface RunbookProcessStepApplyTerraformTemplateActionAwsAccount {
    region?: string;
    /**
     * (see below for nested schema)
     */
    role?: outputs.RunbookProcessStepApplyTerraformTemplateActionAwsAccountRole;
    useInstanceRole?: boolean;
    variable?: string;
}

export interface RunbookProcessStepApplyTerraformTemplateActionAwsAccountRole {
    arn?: string;
    externalId?: string;
    roleSessionName?: string;
    sessionDuration?: number;
}

export interface RunbookProcessStepApplyTerraformTemplateActionAzureAccount {
    variable?: string;
}

export interface RunbookProcessStepApplyTerraformTemplateActionContainer {
    feedId?: string;
    image?: string;
}

export interface RunbookProcessStepApplyTerraformTemplateActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface RunbookProcessStepApplyTerraformTemplateActionGoogleCloudAccount {
    /**
     * Impersonate service accounts
     */
    impersonateServiceAccount?: boolean;
    /**
     * This sets GOOGLE_PROJECT environment variable
     */
    project?: string;
    /**
     * This sets GOOGLE_REGION environment variable
     */
    region?: string;
    /**
     * This sets GOOGLE*IMPERSONATE*SERVICE_ACCOUNT environment variable
     */
    serviceAccountEmails?: string;
    /**
     * When running in a Compute Engine virtual machine, use the associated VM service account
     */
    useVmServiceAccount?: boolean;
    variable?: string;
    /**
     * This sets GOOGLE_ZONE environment variable
     */
    zone?: string;
}

export interface RunbookProcessStepApplyTerraformTemplateActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepApplyTerraformTemplateActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepApplyTerraformTemplateActionTemplate {
    additionalVariableFiles?: string;
    directory?: string;
    runAutomaticFileSubstitution?: boolean;
    targetFiles?: string;
}

export interface RunbookProcessStepDeployKubernetesSecretAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate: outputs.RunbookProcessStepDeployKubernetesSecretActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers: outputs.RunbookProcessStepDeployKubernetesSecretActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency: outputs.RunbookProcessStepDeployKubernetesSecretActionGitDependency;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * Indicates the status of the Kubernetes Object Status feature
     */
    kubernetesObjectStatusCheckEnabled?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages: outputs.RunbookProcessStepDeployKubernetesSecretActionPackage[];
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    /**
     * The name of the secret resource
     */
    secretName: string;
    secretValues: {[key: string]: string};
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface RunbookProcessStepDeployKubernetesSecretActionActionTemplate {
    communityActionTemplateId: string;
    /**
     * The ID of this resource.
     */
    id: string;
    version: number;
}

export interface RunbookProcessStepDeployKubernetesSecretActionContainer {
    feedId?: string;
    image?: string;
}

export interface RunbookProcessStepDeployKubernetesSecretActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface RunbookProcessStepDeployKubernetesSecretActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepDeployPackageAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate: outputs.RunbookProcessStepDeployPackageActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers: outputs.RunbookProcessStepDeployPackageActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency: outputs.RunbookProcessStepDeployPackageActionGitDependency;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages: outputs.RunbookProcessStepDeployPackageActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage: outputs.RunbookProcessStepDeployPackageActionPrimaryPackage;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * Deploy a windows service feature
     */
    windowsService?: outputs.RunbookProcessStepDeployPackageActionWindowsService;
}

export interface RunbookProcessStepDeployPackageActionActionTemplate {
    communityActionTemplateId: string;
    /**
     * The ID of this resource.
     */
    id: string;
    version: number;
}

export interface RunbookProcessStepDeployPackageActionContainer {
    feedId?: string;
    image?: string;
}

export interface RunbookProcessStepDeployPackageActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface RunbookProcessStepDeployPackageActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepDeployPackageActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepDeployPackageActionWindowsService {
    /**
     * The command line arguments that will be passed to the service when it starts
     */
    arguments?: string;
    createOrUpdateService: boolean;
    /**
     * The Windows/domain account of the custom user that the service will run under
     */
    customAccountName?: string;
    /**
     * The password for the custom account
     */
    customAccountPassword: string;
    /**
     * Any dependencies that the service has. Separate the names using forward slashes (/).
     */
    dependencies?: string;
    /**
     * User-friendly description of the service (optional)
     */
    description?: string;
    /**
     * The display name of the service (optional)
     */
    displayName?: string;
    /**
     * The path to the executable relative to the package installation directory
     */
    executablePath: string;
    /**
     * Which built-in account will the service run under. Can be LocalSystem, NT Authority\NetworkService, NT Authority\LocalService, _CUSTOM or an expression
     */
    serviceAccount?: string;
    /**
     * The name of the service
     */
    serviceName: string;
    /**
     * When will the service start. Can be auto, delayed-auto, manual, unchanged or an expression
     */
    startMode?: string;
}

export interface RunbookProcessStepDeployWindowsServiceAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate: outputs.RunbookProcessStepDeployWindowsServiceActionActionTemplate;
    /**
     * The command line arguments that will be passed to the service when it starts
     */
    arguments?: string;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers: outputs.RunbookProcessStepDeployWindowsServiceActionContainer[];
    createOrUpdateService: boolean;
    /**
     * The Windows/domain account of the custom user that the service will run under
     */
    customAccountName?: string;
    /**
     * The password for the custom account
     */
    customAccountPassword: string;
    /**
     * Any dependencies that the service has. Separate the names using forward slashes (/).
     */
    dependencies?: string;
    /**
     * User-friendly description of the service (optional)
     */
    description?: string;
    /**
     * The display name of the service (optional)
     */
    displayName?: string;
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * The path to the executable relative to the package installation directory
     */
    executablePath: string;
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency: outputs.RunbookProcessStepDeployWindowsServiceActionGitDependency;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages: outputs.RunbookProcessStepDeployWindowsServiceActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage: outputs.RunbookProcessStepDeployWindowsServiceActionPrimaryPackage;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
    /**
     * Which built-in account will the service run under. Can be LocalSystem, NT Authority\NetworkService, NT Authority\LocalService, _CUSTOM or an expression
     */
    serviceAccount?: string;
    /**
     * The name of the service
     */
    serviceName: string;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * When will the service start. Can be auto, delayed-auto, manual, unchanged or an expression
     */
    startMode?: string;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
}

export interface RunbookProcessStepDeployWindowsServiceActionActionTemplate {
    communityActionTemplateId: string;
    /**
     * The ID of this resource.
     */
    id: string;
    version: number;
}

export interface RunbookProcessStepDeployWindowsServiceActionContainer {
    feedId?: string;
    image?: string;
}

export interface RunbookProcessStepDeployWindowsServiceActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface RunbookProcessStepDeployWindowsServiceActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepDeployWindowsServiceActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepManualInterventionAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate: outputs.RunbookProcessStepManualInterventionActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers: outputs.RunbookProcessStepManualInterventionActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency: outputs.RunbookProcessStepManualInterventionActionGitDependency;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The instructions for the user to follow
     */
    instructions: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages: outputs.RunbookProcessStepManualInterventionActionPackage[];
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
    /**
     * The teams responsible to resolve this step. If no teams are specified, all users who have permission to deploy the project can resolve it.
     */
    responsibleTeams?: string;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
}

export interface RunbookProcessStepManualInterventionActionActionTemplate {
    communityActionTemplateId: string;
    /**
     * The ID of this resource.
     */
    id: string;
    version: number;
}

export interface RunbookProcessStepManualInterventionActionContainer {
    feedId?: string;
    image?: string;
}

export interface RunbookProcessStepManualInterventionActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface RunbookProcessStepManualInterventionActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepRunKubectlScriptAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate: outputs.RunbookProcessStepRunKubectlScriptActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers: outputs.RunbookProcessStepRunKubectlScriptActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency: outputs.RunbookProcessStepRunKubectlScriptActionGitDependency;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    namespace?: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages: outputs.RunbookProcessStepRunKubectlScriptActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage: outputs.RunbookProcessStepRunKubectlScriptActionPrimaryPackage;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    scriptBody?: string;
    /**
     * The script file name in the package
     */
    scriptFileName?: string;
    /**
     * Parameters expected by the script. Use platform specific calling convention. e.g. -Path #{VariableStoringPath} for PowerShell or -- #{VariableStoringPath} for ScriptCS
     */
    scriptParameters?: string;
    scriptSource: string;
    scriptSyntax: string;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * A newline-separated list of file names to transform, relative to the package contents. Extended wildcard syntax is supported.
     */
    variableSubstitutionInFiles?: string;
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface RunbookProcessStepRunKubectlScriptActionActionTemplate {
    communityActionTemplateId: string;
    /**
     * The ID of this resource.
     */
    id: string;
    version: number;
}

export interface RunbookProcessStepRunKubectlScriptActionContainer {
    feedId?: string;
    image?: string;
}

export interface RunbookProcessStepRunKubectlScriptActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface RunbookProcessStepRunKubectlScriptActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * Whether to extract the package during deployment
     */
    extractDuringDeployment: boolean;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepRunKubectlScriptActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepRunScriptAction {
    /**
     * Represents the template that is associated with this action.
     */
    actionTemplate: outputs.RunbookProcessStepRunScriptActionActionTemplate;
    canBeUsedForProjectVersioning: boolean;
    /**
     * The channels associated with this deployment action.
     */
    channels: string[];
    /**
     * The condition associated with this deployment action.
     */
    condition: string;
    /**
     * The deployment action container associated with this deployment action.
     */
    containers: outputs.RunbookProcessStepRunScriptActionContainer[];
    /**
     * The environments within which this deployment action will run.
     */
    environments: string[];
    /**
     * The environments that this step will be skipped in
     */
    excludedEnvironments: string[];
    /**
     * A list of enabled features for this action.
     */
    features: string[];
    /**
     * Configuration for resource sourcing from a git repository.
     */
    gitDependency: outputs.RunbookProcessStepRunScriptActionGitDependency;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * Indicates the disabled status of this deployment action.
     */
    isDisabled?: boolean;
    /**
     * Indicates the required status of this deployment action.
     */
    isRequired?: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The notes associated with this deployment action.
     */
    notes?: string;
    /**
     * The package assocated with this action.
     */
    packages: outputs.RunbookProcessStepRunScriptActionPackage[];
    /**
     * The package assocated with this action.
     */
    primaryPackage: outputs.RunbookProcessStepRunScriptActionPrimaryPackage;
    /**
     * A list of properties associated with this package.
     *
     * @deprecated This attribute is deprecated and will be removed in a future release. Please use the attributes that match the properties that are stored to this map.
     */
    properties: {[key: string]: string};
    /**
     * Whether this step runs on a worker or on the target
     */
    runOnServer?: boolean;
    scriptBody?: string;
    /**
     * The script file name in the package
     */
    scriptFileName?: string;
    /**
     * Parameters expected by the script. Use platform specific calling convention. e.g. -Path #{VariableStoringPath} for PowerShell or -- #{VariableStoringPath} for ScriptCS
     */
    scriptParameters?: string;
    scriptSource: string;
    scriptSyntax: string;
    /**
     * The human-readable unique identifier for this resource.
     */
    slug: string;
    sortOrder?: number;
    /**
     * A list of tenant tags associated with this resource.
     */
    tenantTags: string[];
    /**
     * A newline-separated list of file names to transform, relative to the package contents. Extended wildcard syntax is supported.
     */
    variableSubstitutionInFiles?: string;
    /**
     * The worker pool associated with this deployment action.
     */
    workerPoolId?: string;
    /**
     * The worker pool variable associated with this deployment action.
     */
    workerPoolVariable?: string;
}

export interface RunbookProcessStepRunScriptActionActionTemplate {
    communityActionTemplateId: string;
    /**
     * The ID of this resource.
     */
    id: string;
    version: number;
}

export interface RunbookProcessStepRunScriptActionContainer {
    feedId?: string;
    image?: string;
}

export interface RunbookProcessStepRunScriptActionGitDependency {
    /**
     * Name of the default branch of the repository.
     */
    defaultBranch: string;
    /**
     * List of file path filters used to narrow down the directory where files are to be sourced from. Supports glob patten syntax.
     */
    filePathFilters?: string[];
    /**
     * ID of an existing Git credential.
     */
    gitCredentialId?: string;
    /**
     * The Git credential authentication type.
     */
    gitCredentialType: string;
    /**
     * The Git URI for the repository where this resource is sourced from.
     */
    repositoryUri: string;
}

export interface RunbookProcessStepRunScriptActionPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * Whether to extract the package during deployment
     */
    extractDuringDeployment: boolean;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface RunbookProcessStepRunScriptActionPrimaryPackage {
    /**
     * Whether to acquire this package on the server ('Server'), target ('ExecutionTarget') or not at all ('NotAcquired'). Can be an expression
     */
    acquisitionLocation?: string;
    /**
     * The feed ID associated with this package reference.
     */
    feedId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of this resource.
     */
    name?: string;
    /**
     * The ID of the package.
     */
    packageId: string;
    /**
     * A list of properties associated with this package.
     */
    properties: {[key: string]: string};
}

export interface SshConnectionDeploymentTargetEndpoint {
    aadClientCredentialSecret?: string;
    aadCredentialType?: string;
    aadUserCredentialUsername?: string;
    accountId?: string;
    applicationsDirectory?: string;
    authentication: outputs.SshConnectionDeploymentTargetEndpointAuthentication;
    certificateSignatureAlgorithm?: string;
    certificateStoreLocation?: string;
    certificateStoreName?: string;
    clientCertificateVariable?: string;
    cloudServiceName?: string;
    clusterCertificate?: string;
    clusterCertificatePath?: string;
    clusterUrl?: string;
    communicationStyle: string;
    connectionEndpoint?: string;
    containerOptions?: string;
    containers: outputs.SshConnectionDeploymentTargetEndpointContainer[];
    defaultWorkerPoolId?: string;
    destinations: outputs.SshConnectionDeploymentTargetEndpointDestination[];
    dotNetCorePlatform?: string;
    fingerprint?: string;
    host?: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
    namespace?: string;
    port?: number;
    proxyId?: string;
    resourceGroupName?: string;
    runningInContainer?: boolean;
    securityMode?: string;
    serverCertificateThumbprint?: string;
    skipTlsVerification?: boolean;
    slot?: string;
    storageAccountName?: string;
    swapIfPossible?: boolean;
    tentacleVersionDetails: outputs.SshConnectionDeploymentTargetEndpointTentacleVersionDetail[];
    thumbprint?: string;
    uri?: string;
    useCurrentInstanceCount?: boolean;
    webAppName?: string;
    webAppSlotName?: string;
    workingDirectory?: string;
}

export interface SshConnectionDeploymentTargetEndpointAuthentication {
    accountId?: string;
    adminLogin?: string;
    assumeRole?: boolean;
    assumeRoleExternalId?: string;
    assumeRoleSessionDuration?: number;
    assumedRoleArn?: string;
    assumedRoleSession?: string;
    authenticationType?: string;
    clientCertificate?: string;
    clusterName?: string;
    clusterResourceGroup?: string;
    impersonateServiceAccount?: boolean;
    project?: string;
    region?: string;
    serviceAccountEmails?: string;
    tokenPath?: string;
    useInstanceRole?: boolean;
    useVmServiceAccount?: boolean;
    zone?: string;
}

export interface SshConnectionDeploymentTargetEndpointContainer {
    feedId?: string;
    image?: string;
}

export interface SshConnectionDeploymentTargetEndpointDestination {
    destinationType?: string;
    dropFolderPath?: string;
}

export interface SshConnectionDeploymentTargetEndpointTentacleVersionDetail {
    upgradeLocked: boolean;
    upgradeRequired: boolean;
    upgradeSuggested: boolean;
    version: string;
}

export interface TeamExternalSecurityGroup {
    displayIdAndName: boolean;
    displayName: string;
    /**
     * The unique ID for this resource.
     */
    id: string;
}

export interface TeamUserRole {
    environmentIds?: string[];
    /**
     * The ID of this resource.
     */
    id: string;
    projectGroupIds?: string[];
    projectIds?: string[];
    spaceId: string;
    teamId: string;
    tenantIds?: string[];
    userRoleId: string;
}

export interface UserIdentity {
    claims?: outputs.UserIdentityClaim[];
    provider?: string;
}

export interface UserIdentityClaim {
    isIdentifyingClaim: boolean;
    /**
     * The name of this resource.
     */
    name: string;
    value: string;
}

